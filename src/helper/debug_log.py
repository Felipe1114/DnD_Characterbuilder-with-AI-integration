"""How to use:from src.helper.debug_log import DebugLog@DebugLog.debug_logdef do_smth():	..."""# TODO: ab hier weiter mit cleanup machenimport loggingimport osimport tracebackfrom sqlalchemy.exc import SQLAlchemyError, ArgumentErrorfrom functools import wrapsfrom requests import HTTPErrorfrom mistralai.models.sdkerror import SDKErrorclass DebugLog:	log_file_path = os.path.abspath(os.path.join(os.path.dirname(__file__), "../../data/debug_data/helper.log"))		@staticmethod	def _setup_logger():		"""		makes the basic configurations for the logging tool"""		logging.basicConfig(			filename=DebugLog.log_file_path,			level=logging.ERROR,			format="%(asctime)s - %(levelname)s - %(message)s"		)	@staticmethod	def log_error():		"""loggs an error"""		DebugLog._setup_logger()		message = f"{traceback.format_exc()}"		logging.error(message) # saves the message in log-file		print(message)  # desplays the log-message in terminal	# decorator method	@staticmethod	def debug_log(func):		"""wraps the funktion/method and calls exception"""		@wraps(func)		def wrapper(*args, **kwargs):			try:				return func(*args, **kwargs)			# TODO: exception aufsplitten			# calls all possible Errors			except (ValueError, TypeError, AttributeError, SyntaxError, SQLAlchemyError, ArgumentError, HTTPError, SDKError) as e:				tb = traceback.extract_tb(e.__traceback__)				last_trace = tb[-1]								DebugLog.log_error()				print(f"Error: {func.__name__}: {e}")								return None		return wrapper    